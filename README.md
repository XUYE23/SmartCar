# SmartCar


## 1. 项目概述

本项目旨在解决无人车路径规划与优化问题。我们利用给定的高精度数字高程模型（DEM），结合无人车的性能参数和运动学约束，开发了一套包含**路径评估**、**合规性校验**和**路径优化**三个核心功能的计算模型。

- **技术栈**: Python 3.9+
- **核心库**: NumPy, Pandas, Rasterio, Matplotlib, Tqdm, Openpyxl

## 2. 问题描述

我们需要对A型无人车的行驶路径进行分析和规划。任务背景设定在一个 `62.5km x 62.5km` 的山地区域，地形数据由一个 `12500x12500` 的栅格地图给出。

本项目需要解决三个核心问题：

1.  **问题一：路径性能评估**
    对一条给定的完整路径（P1->P2），计算其四个关键性能指标：**里程**、**时效性**（总用时）、**平稳性**（颠簸程度）和**安全性**（在不良区域的用时），并绘制相关的性能曲线。

2.  **问题二：路径合规性校验**
    对另一条给定路径（P3->P4），检查其是否违反了无人车的两大核心约束：最大通行坡度（30度）和运动学转向规则（每次移动最多转弯90度）。

3.  **问题三：路径朝向优化**
    对于一条已确定栅格序列但未指定朝向的路径（P5->P6），利用算法找到一条全局最优的朝向序列，使得总行驶里程最短。

## 3. 建模方法与实现

我们采用分步、模块化的方式来构建整个解决方案，确保代码的清晰、可维护和高效。

### 3.1. 阶段一：地形数据预处理 (`01_preprocess.py`)

这是所有分析的基础。为了避免在后续计算中反复读取和计算地形属性，我们进行了一次性预处理。

- **方法**:
    1.  使用 `rasterio` 库读取 `map.tif` 高程地图。
    2.  遍历地图中的每一个栅格（非边界），利用其3x3邻域的高程数据，根据官方文档给出的公式计算以下核心属性：
        - **坡度 (Slope)**
        - **坡向 (Aspect)**
        - **坡面法向量 (Normal Vector)**
    3.  为了优化性能和内存占用，所有计算出的属性矩阵均以 `float32` 格式存储。
    4.  最终，将高程、坡度、坡向、法向量等所有预处理好的大型NumPy数组，压缩并保存到一个单一的 `.npz` 文件 (`preprocessed_data.npz`) 中。
- **效果**: 此步骤将后续所有地形查询的时间复杂度从复杂的计算降低为 **O(1)** 的数组索引操作，极大地提升了整体效率。虽然此步骤耗时较长（数分钟），但其一次性投入为后续的快速分析奠定了基础。

### 3.2. 阶段二：路径评估与校验 (问题 1 & 2)

这两个问题本质上都是对给定路径的序列化分析。

- **方法 (`02_solve_problem_1.py`, `03_solve_problem_2.py`)**:
    1.  **序列迭代模拟器**: 通过 `for` 循环遍历路径中的每一步（从 `L_i` 到 `L_{i+1}`）。
    2.  **数据查询**: 在每一步中，根据当前栅格坐标，从预处理的 `.npz` 文件中快速加载坡度、法向量等数据。
    3.  **指标计算**:
        - **里程**: 通过 `(ΔL, Δθ)` 查阅官方里程加权系数表 `ω` 计算。特别注意 `Δθ` 的计算需要考虑角度的周期性（例如，从0度到315度是转45度，而不是315度）。
        - **时效性**: 根据当前栅格的坡度查询速度表，用 `距离/速度` 计算时间。
        - **平稳性**: 根据相邻栅格的平均坡度和法向量夹角计算。
        - **安全性**: 通过哈希集合（`set`）快速判断当前栅格是否在不良区域内，并累加相应时间。
    4.  **合规性校验**:
        - **坡度**: 直接比较当前坡度与最大允许坡度。
        - **转向**: 构建一个转向规则查找表（字典），将附件中的图示规则程序化，实现 O(1) 的合法性查询。

- **效果**:
    - **问题一**: 成功计算出P1->P2路径的各项指标，并生成了包含**里程-时间、高程-里程、坡度-里程、速度-里程**四张曲线的综合性能分析图。
    - **问题二**: 成功检测出P3->P4路径中所有不符合运动学规则的“车头方向错误”，并生成了清晰的 `.xlsx` 报告。

好的，这是针对 `README.md` 中第三阶段部分的重写版本。这个新版本反映了我们对问题三的更深刻理解，以及最终采用的、逻辑更严谨的动态规划算法。

---

### 3.3. 阶段三：路径朝向优化（问题 3）

这是整个项目中技术复杂度最高、最核心的部分。其目标是为一条已确定栅格序列但未指定朝向的路径，找到一个全局最优的朝向序列，以最小化总行驶里程。

#### 建模方法：动态规划 (Dynamic Programming)

我们确定，这是一个典型的序列决策优化问题，非常适合使用**动态规划**来寻找精确的最优解。我们最终实现的算法，在思想上与处理隐马尔可夫模型的**维特比算法 (Viterbi Algorithm)** 高度相似。

- **状态定义 `State(i, h)`**: 代表无人车行驶到第 `i` 个路径点（`L_i`），且到达时车头朝向为 `h`。
- **DP表 `dp[i][h]`**: 存储到达状态 `State(i, h)` 所需的最小累计里程。
- **状态转移**: `dp` 表的填充过程是算法的核心，它严格遵循 `附件3` 中描述的车辆运动学规则。

#### 关键逻辑的演进与最终实现 (`04_solve_problem_3_correct_dp.py`)

在实现过程中，我们对问题的理解不断加深，算法模型也经历了重要的迭代：

1.  **初步模型的错误与修正**: 我们最初的实现基于一个错误的简化假设——认为一个移动向量 `(dx, dy)` 会唯一确定车辆的目标朝向。通过对 `附件3` 规则的再次深入研读，我们发现这是不正确的。

2.  **正确的规则解读**: `附件3` 图2明确指出，车辆完成一次移动后，其**后继朝向 `h_curr` 并非唯一**。它是一个依赖于**前一朝向 `h_prev`** 和**移动类型**（直行、左转45度、右转45度）的**选择集合**（通常有2到3个选项）。

3.  **最终的正确实现**:
    *   **构建精确的转向逻辑表**: 我们创建了一个新的辅助函数 `build_turn_logic()`，它忠实地将 `附件3` 的图示规则转化为一个精细的查找表。该表能够根据任意的 `h_prev` 和实际的移动向量 `(dx, dy)`，返回所有可能的、合法的 `h_curr` 列表。
    *   **实现完整的三层状态转移**: 算法的核心循环被重构为正确的三层逻辑嵌套：
        1.  遍历**路径点 `i`** (阶段)。
        2.  遍历所有**可能的前一朝向 `h_prev`**。
        3.  遍历从 `(i-1, h_prev)` 出发，可以完成目标移动 `L_{i-1} -> L_i` 后，所有**可能的后继朝向 `h_curr`**。
    *   **处理初始状态**: 对于未定义的P5点起始朝向，我们做出了最合理的假设：考虑所有能够完成第一步移动 `P5 -> L1` 的、可能的P5朝向，并为它们在L1对应的所有后继状态赋予一个无转弯惩罚的初始成本。

#### 成果与对比验证

- **成果**: 最终版本的动态规划算法成功地为 `P5->P6` 路径规划出了一条总里程最短的、完整的朝向序列，并将结果输出到 `problem3_results_correct_dp.xlsx` 文件中。
- **对比实验**: 为了验证算法的优越性，我们还分别实现了**贪心算法**和**A\*算法**作为对比。
    - **A\* 算法**: 作为另一种精确算法，其结果与我们的动态规划解完全一致，验证了我们找到了**全局最优解**。
    - **贪心算法**: 有趣的是，对于 `P5-P6` 这条特定的路径，贪心算法也得出了相同的最优解。这揭示了该路径序列本身具有一种“单纯”的几何特性，使得局部最优选择恰好构成了全局最优路径。然而，我们深知这种巧合不具备普适性，对于更复杂的“陷阱”路径，只有动态规划和A\*能保证最优性。

最终，通过严谨的建模和对比实验，我们证明了所采用的**动态规划算法**是解决此类问题**最可靠、最健壮**的方法。

## 4. 如何运行

1.  **环境配置**:
    - 确保已安装 Python 3.9 或更高版本。
    - 安装所有必需的库：
      ```bash
      pip install numpy pandas rasterio matplotlib tqdm openpyxl
      ```

2.  **文件准备**:
    - 将所有脚本文件 (`.py`)、地形图 `map.tif` 和所有数据文件 (`.xlsx`) 放置在同一个目录下。
    - 打开 `config.py` 文件，确保其中定义的文件路径与您的实际文件名相匹配。

3.  **执行顺序**:
    - 按以下顺序在终端中运行脚本。**必须先运行预处理脚本**。
      ```bash
      # 步骤 1: 生成预处理数据 (仅需运行一次)
      python 01_preprocess.py

      # 步骤 2: 解决问题一
      python 02_solve_problem_1.py

      # 步骤 3: 解决问题二
      python 03_solve_problem_2.py

      # 步骤 4: 解决问题三
      python 04_solve_problem_3.py
      ```

4.  **查看结果**:
    - 运行完成后，`problem1_results.png` 图表、`problem2_results.xlsx` 和 `problem3_results.xlsx` 报告将生成在同一目录下。

---
